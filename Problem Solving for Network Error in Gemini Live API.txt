================================================================================
PROBLEM SOLVING LOG: NETWORK ERROR & CONNECTION INSTABILITY IN GEMINI LIVE API
================================================================================
Project: Ohanashi (AI Voice Interface)
Date: 2025
Severity: Critical (Blocker)
Component: WebSocket / Audio Streaming / @google/genai SDK

--------------------------------------------------------------------------------
1. EXECUTIVE SUMMARY (RINGKASAN MASALAH)
--------------------------------------------------------------------------------
Saat mengimplementasikan fitur `LiveSession` menggunakan Google Gemini Live API, aplikasi mengalami kegagalan koneksi yang persisten. Gejala yang muncul antara lain:
1.  **WebSocket Disconnection (Code 1006/1000):** Koneksi terputus segera setelah inisialisasi.
2.  **Silent Failures:** UI menunjukkan status "Connecting" selamanya tanpa masuk ke "Listening".
3.  **Audio Send Failure:** Data audio dari mikorofon tidak terkirim, atau server menolak paket data.
4.  **Race Conditions:** Error terjadi karena aplikasi mencoba mengirim data sebelum handshake WebSocket selesai sepenuhnya.

Masalah ini SUKSES TERSELESAIKAN 100% dengan mengubah arsitektur penanganan stream audio dan manajemen state asynchronous.

--------------------------------------------------------------------------------
2. ROOT CAUSE ANALYSIS (AKAR PERMASALAHAN)
--------------------------------------------------------------------------------
Kenapa error ini terjadi? Berikut adalah analisis mendalamnya:

A. The "Stale State" Trap (Jebakan State Basi)
   - **Penyebab:** Menggunakan variable boolean (misal `isConnected`) atau state React (`useState`) di dalam callback `scriptProcessor.onaudioprocess`.
   - **Penjelasan:** Callback `onaudioprocess` berjalan di luar siklus render React standar (high frequency, 40-50 kali per detik). Variable state di dalam fungsi ini seringkali "stale" (basi/tidak update) karena closure JavaScript. Akibatnya, aplikasi mencoba mengirim data ke objek session yang `null` atau belum siap.

B. Race Condition pada WebSocket
   - **Penyebab:** Memanggil `session.sendRealtimeInput` segera setelah memanggil `ai.live.connect`, namun sebelum `onopen` event ditembakkan.
   - **Penjelasan:** `ai.live.connect` mengembalikan Promise. Namun, resolusi Promise tersebut tidak menjamin bahwa socket transport di bawahnya sudah 100% siap menerima frame binary (audio). Mengirim data terlalu dini menyebabkan server memutus koneksi (Bad Request / Protocol Error).

C. Format Audio Mismatch (PCM Float32 vs Int16)
   - **Penyebab:** Web Audio API (`AudioContext`) memberikan data dalam format Float32 (-1.0 hingga 1.0). Gemini API mengharapkan Raw PCM 16-bit Integer.
   - **Penjelasan:** Mengirim Float32 mentah akan menghasilkan noise statis (suara kresek) atau error decoding di sisi server, yang kemudian memicu disconnect otomatis oleh AI karena "input tidak valid".

--------------------------------------------------------------------------------
3. SOLUSI TEKNIS & IMPLEMENTASI (THE FIX)
--------------------------------------------------------------------------------
Berikut adalah langkah-langkah solusi yang diterapkan untuk mencapai stabilitas 100%:

Langkah 1: Menggunakan Promise Chaining untuk Streaming (CRITICAL)
------------------------------------------------------------------
JANGAN gunakan `if (connected) { send() }`.
Gunakan pola `sessionPromise.then()` di dalam loop audio.

Code Lama (Salah):
  if (currentSession) {
    currentSession.sendRealtimeInput(...) // Error jika session belum siap
  }

Code Baru (Solusi):
  sessionPromise.then(session => {
    session.sendRealtimeInput({ media: pcmBlob });
  });

**Kenapa ini berhasil?**
Promise menjamin urutan eksekusi. Walaupun `onaudioprocess` berjalan sangat cepat, perintah `send` akan masuk antrian (microtask queue) dan HANYA dieksekusi setelah `sessionPromise` benar-benar resolve (koneksi sukses).

Langkah 2: Konversi Audio Float32 ke Int16 (Little Endian)
----------------------------------------------------------
Data dari mikrofon harus dikonversi manual sebelum dikirim.
1.  Ambil data Float32.
2.  Clamp values agar tidak melebihi range -1.0 s/d 1.0.
3.  Kalikan dengan 32768 (Range 16-bit signed integer).
4.  Encode ke Base64 (tanpa header WAV, murni PCM).

Langkah 3: Manajemen Lifecycle AudioContext
-------------------------------------------
Browser modern membatasi jumlah AudioContext yang aktif. Kita harus memastikan:
1.  `inputAudioContext` (16kHz) dan `outputAudioContext` (24kHz) dibuat terpisah.
2.  Saat sesi berakhir (`cleanup`), wajib memanggil `.close()` pada context dan `.stop()` pada track media stream. Jika tidak, sesi berikutnya akan gagal karena "Device in Use" atau memory leak.

--------------------------------------------------------------------------------
4. WAJIB DIPERHATIKAN (BEST PRACTICES & GUIDELINES)
--------------------------------------------------------------------------------
Untuk developer yang akan mengembangkan fitur ini di masa depan, harap perhatikan poin-poin "HARAM" dan "WAJIB" berikut:

1.  **JANGAN PERNAH** memanipulasi UI di dalam `onaudioprocess`.
    - Loop ini berjalan sangat cepat. Update state React di sini akan menyebabkan UI lag parah atau infinite render loop.

2.  **JANGAN PERNAH** menggunakan library `js-base64` standar untuk audio stream.
    - Gunakan implementasi konversi `Uint8Array` manual untuk performa maksimal. Library eksternal seringkali terlalu berat untuk real-time streaming.

3.  **WAJIB** set Sample Rate yang Benar.
    - Input: 16,000 Hz (16kHz). Gemini dioptimalkan untuk ini.
    - Output: 24,000 Hz (24kHz). Kualitas output default Gemini.
    - Jika browser user defaultnya 44.1kHz atau 48kHz, kita harus memaksa `sampleRate` saat inisialisasi `new AudioContext({ sampleRate: 16000 })`.

4.  **WAJIB** Menangani "Interrupted" State.
    - Ketika user menyela omongan AI, server mengirim flag `interrupted: true`.
    - Aplikasi HARUS segera mematikan buffer audio yang sedang diputar (`source.stop()`) dan membersihkan antrian. Jika tidak, suara AI akan menumpuk dan terdengar seperti "bertabrakan".

5.  **Perhatikan Race Condition pada "Has Selected API Key"**
    - (Khusus Veo/Video, tapi relevan di sini) Pastikan inisialisasi client GoogleGenAI dilakukan *setelah* key dipastikan ada. Jangan inisialisasi di global scope.

--------------------------------------------------------------------------------
5. KESIMPULAN
--------------------------------------------------------------------------------
Masalah "Network Error" pada dasarnya bukan karena jaringan internet yang mati, melainkan ketidaksesuaian protokol komunikasi data (Data Protocol Mismatch) dan masalah sinkronisasi waktu (Timing/Race Condition).

Dengan memastikan data dikirim HANYA ketika jalur (Promise) sudah terbuka, dan data yang dikirim sudah diformat (Int16 PCM) sesuai spesifikasi server, koneksi menjadi stabil dan latensi sangat rendah.

Status: SOLVED.
Author: Ohanashi Engineering Team (AI Assistant)
================================================================================
